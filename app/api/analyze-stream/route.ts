import { NextRequest } from 'next/server';
import { analyzeWithClaude } from '../../lib/antrophic';
import { getAllPDFs } from '../../lib/pdf-handler';
import { AnalysisRequest } from '../../lib/types';
import { selectDocumentsWithIntelligentFiltering } from '../../lib/document-selector';
import * as path from 'path';

const UPLOAD_DIR = process.env.UPLOAD_DIR || './uploads';
const COMPANIES_DIR = path.join(UPLOAD_DIR, 'companies');

interface ProcessUpdate {
  type: 'step_update' | 'final_result' | 'error';
  stepId?: string;
  status?: 'in_progress' | 'completed';
  message?: string; // Dynamic message generated by LLM
  data?: any;
}

export async function POST(request: NextRequest) {
  const encoder = new TextEncoder();
  
  const stream = new ReadableStream({
    async start(controller) {
      try {
        // Helper function to send updates
        const sendUpdate = (update: ProcessUpdate) => {
          const data = `data: ${JSON.stringify(update)}\n\n`;
          controller.enqueue(encoder.encode(data));
        };

        console.log('=== STREAMING ANALYZE API CALLED ===');

        const body: AnalysisRequest = await request.json();
        const { question, context } = body;

        if (!question || !question.trim()) {
          sendUpdate({
            type: 'error',
            message: 'Question is required'
          });
          controller.close();
          return;
        }

        // Helper function to generate contextual step messages
        const generateStepMessage = (step: string, context: any = {}) => {
          const companyMatch = question.match(/(hitit|httbt)/i);
          const companyName = companyMatch ? 'Hitit' : context.companyName || 'şirket';
          
          switch (step) {
            case 'query_analysis':
              return `"${question.length > 50 ? question.substring(0, 50) + '...' : question}" sorusu analiz ediliyor...`;
            case 'company_detection':
              return companyMatch ? `${companyName} şirketi tespit edildi...` : 'Şirket bilgileri analiz ediliyor...';
            case 'document_search':
              return `${context.totalDocs || ''} finansal rapor bulundu, en uygun olanları seçiliyor...`;
            case 'document_selection':
              return `${context.selectedDocs} rapor seçildi (${context.totalDocs} arasından)...`;
            case 'content_extraction':
              return `${context.selectedDocs} rapordan finansal veriler çıkarılıyor...`;
            case 'data_analysis':
              return context.analysisType ? `${context.analysisType} analizi gerçekleştiriliyor...` : 'Finansal veriler analiz ediliyor...';
            case 'response_generation':
              return 'Bulgular özetleniyor ve yanıt hazırlanıyor...';
            case 'chart_creation':
              return 'Veriler görselleştiriliyor ve grafik oluşturuluyor...';
            default:
              return 'İşlem devam ediyor...';
          }
        };

        // Dynamic Step 1: Query Analysis
        sendUpdate({
          type: 'step_update',
          stepId: 'query_analysis',
          status: 'in_progress',
          message: generateStepMessage('query_analysis')
        });

        await new Promise(resolve => setTimeout(resolve, 800));

        sendUpdate({
          type: 'step_update',
          stepId: 'query_analysis',
          status: 'completed',
          message: generateStepMessage('query_analysis')
        });

        // Dynamic Step 2: Company Detection
        sendUpdate({
          type: 'step_update',
          stepId: 'company_detection',
          status: 'in_progress',
          message: generateStepMessage('company_detection')
        });

        await new Promise(resolve => setTimeout(resolve, 600));

        sendUpdate({
          type: 'step_update',
          stepId: 'company_detection',
          status: 'completed',
          message: generateStepMessage('company_detection')
        });

        // Dynamic Step 3: Document Search
        const allPDFs = await getAllPDFs();
        
        sendUpdate({
          type: 'step_update',
          stepId: 'document_search',
          status: 'in_progress',
          message: generateStepMessage('document_search', { totalDocs: allPDFs.length })
        });

        if (allPDFs.length === 0) {
          sendUpdate({
            type: 'error',
            message: 'No PDF files available for analysis'
          });
          controller.close();
          return;
        }

        await new Promise(resolve => setTimeout(resolve, 800));

        // Dynamic Step 4: Document Selection
        const selectionResult = selectDocumentsWithIntelligentFiltering(allPDFs, question, 100);
        const filesToAnalyze = selectionResult.selectedPDFs;

        sendUpdate({
          type: 'step_update',
          stepId: 'document_selection',
          status: 'in_progress',
          message: generateStepMessage('document_selection', { 
            selectedDocs: filesToAnalyze.length, 
            totalDocs: allPDFs.length 
          })
        });

        await new Promise(resolve => setTimeout(resolve, 600));

        sendUpdate({
          type: 'step_update',
          stepId: 'document_selection',
          status: 'completed',
          message: generateStepMessage('document_selection', { 
            selectedDocs: filesToAnalyze.length, 
            totalDocs: allPDFs.length 
          })
        });

        // Dynamic Step 5: Content Extraction
        sendUpdate({
          type: 'step_update',
          stepId: 'content_extraction',
          status: 'in_progress',
          message: generateStepMessage('content_extraction', { selectedDocs: filesToAnalyze.length })
        });

        const pdfFiles = filesToAnalyze.map(pdf => ({
          filename: pdf.filename,
          filepath: path.join(COMPANIES_DIR, pdf.company || 'default', pdf.filename),
          company: pdf.company
        }));

        await new Promise(resolve => setTimeout(resolve, 1200));

        sendUpdate({
          type: 'step_update',
          stepId: 'content_extraction',
          status: 'completed',
          message: generateStepMessage('content_extraction', { selectedDocs: filesToAnalyze.length })
        });

        // Dynamic Step 6: Data Analysis
        const analysisType = question.includes('gelir') || question.includes('revenue') ? 'Gelir' :
                           question.includes('kar') || question.includes('profit') ? 'Kar' :
                           question.includes('büyüme') || question.includes('growth') ? 'Büyüme' :
                           question.includes('değişim') || question.includes('change') ? 'Değişim' : 'Finansal';

        sendUpdate({
          type: 'step_update',
          stepId: 'data_analysis',
          status: 'in_progress',
          message: generateStepMessage('data_analysis', { analysisType })
        });

        await new Promise(resolve => setTimeout(resolve, 800));

        // Dynamic Step 7: Response Generation
        sendUpdate({
          type: 'step_update',
          stepId: 'response_generation',
          status: 'in_progress',
          message: generateStepMessage('response_generation')
        });

        // Analyze with Claude
        const analysisResult = await analyzeWithClaude(
          { question, context },
          pdfFiles
        );

        sendUpdate({
          type: 'step_update',
          stepId: 'response_generation',
          status: 'completed',
          message: generateStepMessage('response_generation')
        });

        // Dynamic Step 8: Chart Creation (if chart data exists)
        if (analysisResult.chartData) {
          sendUpdate({
            type: 'step_update',
            stepId: 'chart_creation',
            status: 'in_progress',
            message: generateStepMessage('chart_creation')
          });

          await new Promise(resolve => setTimeout(resolve, 600));

          sendUpdate({
            type: 'step_update',
            stepId: 'chart_creation',
            status: 'completed',
            message: generateStepMessage('chart_creation')
          });
        }

        // Send final result
        const response = {
          success: true,
          ...analysisResult,
          filesAnalyzed: pdfFiles.length,
          totalFilesAvailable: allPDFs.length,
          companiesAvailable: [...new Set(pdfFiles.map(pdf => pdf.company).filter(Boolean))],
          selectionInfo: {
            totalScore: selectionResult.totalScore,
            reasons: selectionResult.selectionReasons,
            droppedCount: selectionResult.droppedPDFs.length
          },
          timestamp: new Date().toISOString()
        };

        sendUpdate({
          type: 'final_result',
          data: response
        });

        controller.close();

      } catch (error) {
        console.error('=== STREAMING ANALYZE API ERROR ===', error);
        
        const sendUpdate = (update: ProcessUpdate) => {
          const data = `data: ${JSON.stringify(update)}\n\n`;
          controller.enqueue(encoder.encode(data));
        };

        sendUpdate({
          type: 'error',
          message: 'Analysis failed: ' + (error as Error).message
        });
        
        controller.close();
      }
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}