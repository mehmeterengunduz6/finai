import { NextRequest } from 'next/server';
import { analyzeWithClaude } from '../../lib/antrophic';
import { getAllPDFs } from '../../lib/pdf-handler';
import { AnalysisRequest } from '../../lib/types';
import { selectDocumentsWithLLM, selectDocumentsWithIntelligentFiltering } from '../../lib/document-selector';
import * as path from 'path';

const UPLOAD_DIR = process.env.UPLOAD_DIR || './uploads';
const COMPANIES_DIR = path.join(UPLOAD_DIR, 'companies');

interface ProcessUpdate {
  type: 'step_update' | 'final_result' | 'error';
  stepId?: string;
  status?: 'in_progress' | 'completed';
  message?: string; // Dynamic message generated by LLM
  data?: any;
}

export async function POST(request: NextRequest) {
  const encoder = new TextEncoder();
  
  const stream = new ReadableStream({
    async start(controller) {
      try {
        // Helper function to send updates
        const sendUpdate = (update: ProcessUpdate) => {
          const data = `data: ${JSON.stringify(update)}\n\n`;
          controller.enqueue(encoder.encode(data));
        };

        console.log('=== STREAMING ANALYZE API CALLED ===');

        const body: AnalysisRequest = await request.json();
        const { question, context } = body;

        if (!question || !question.trim()) {
          sendUpdate({
            type: 'error',
            message: 'Question is required'
          });
          controller.close();
          return;
        }

        // Helper function to generate contextual step messages
        const generateStepMessage = (step: string, context: any = {}) => {
          const companyMatch = question.match(/(hitit|httbt)/i);
          const companyName = companyMatch ? 'Hitit' : context.companyName || 'ÅŸirket';
          
          switch (step) {
            case 'query_analysis':
              return `"${question.length > 50 ? question.substring(0, 50) + '...' : question}" sorusu analiz ediliyor...`;
            case 'company_detection':
              return companyMatch ? `${companyName} ÅŸirketi tespit edildi...` : 'Åžirket bilgileri analiz ediliyor...';
            case 'document_search':
              return `${context.totalDocs || ''} finansal rapor bulundu, en uygun olanlarÄ± seÃ§iliyor...`;
            case 'document_selection':
              return `${context.selectedDocs} rapor seÃ§ildi (${context.totalDocs} arasÄ±ndan)...`;
            case 'content_extraction':
              return `${context.selectedDocs} rapordan finansal veriler Ã§Ä±karÄ±lÄ±yor...`;
            case 'data_analysis':
              return context.analysisType ? `${context.analysisType} analizi gerÃ§ekleÅŸtiriliyor...` : 'Finansal veriler analiz ediliyor...';
            case 'response_generation':
              return 'Bulgular Ã¶zetleniyor ve yanÄ±t hazÄ±rlanÄ±yor...';
            case 'chart_creation':
              return 'Veriler gÃ¶rselleÅŸtiriliyor ve grafik oluÅŸturuluyor...';
            default:
              return 'Ä°ÅŸlem devam ediyor...';
          }
        };

        // Dynamic Step 1: Query Analysis
        sendUpdate({
          type: 'step_update',
          stepId: 'query_analysis',
          status: 'in_progress',
          message: generateStepMessage('query_analysis')
        });

        await new Promise(resolve => setTimeout(resolve, 800));

        sendUpdate({
          type: 'step_update',
          stepId: 'query_analysis',
          status: 'completed',
          message: generateStepMessage('query_analysis')
        });

        // Dynamic Step 2: Company Detection
        sendUpdate({
          type: 'step_update',
          stepId: 'company_detection',
          status: 'in_progress',
          message: generateStepMessage('company_detection')
        });

        await new Promise(resolve => setTimeout(resolve, 600));

        sendUpdate({
          type: 'step_update',
          stepId: 'company_detection',
          status: 'completed',
          message: generateStepMessage('company_detection')
        });

        // Dynamic Step 3: Document Search
        const allPDFs = await getAllPDFs();
        
        sendUpdate({
          type: 'step_update',
          stepId: 'document_search',
          status: 'in_progress',
          message: generateStepMessage('document_search', { totalDocs: allPDFs.length })
        });

        if (allPDFs.length === 0) {
          sendUpdate({
            type: 'error',
            message: 'No PDF files available for analysis'
          });
          controller.close();
          return;
        }

        await new Promise(resolve => setTimeout(resolve, 800));

        // Dynamic Step 4: Document Selection - Use LLM for intelligent selection
        const selectionResult = await selectDocumentsWithLLM(allPDFs, question, 50);
        const filesToAnalyze = selectionResult.selectedPDFs;

        sendUpdate({
          type: 'step_update',
          stepId: 'document_selection',
          status: 'in_progress',
          message: 'LLM analiz ediyor ve en uygun raporlarÄ± seÃ§iyor...'
        });

        await new Promise(resolve => setTimeout(resolve, 600));

        // Extract and log LLM reasoning (for console debugging, not UI)
        const llmReasoning = selectionResult.selectionReasons.find(reason => 
          reason.startsWith('LLM Reasoning:')
        )?.replace('LLM Reasoning: ', '');
        
        const coverageInfo = selectionResult.selectionReasons.find(reason => 
          reason.startsWith('Coverage:')
        )?.replace('Coverage: ', '');
        
        // Log LLM thinking process to console for debugging
        if (llmReasoning) {
          console.log('ðŸ¤– LLM Document Selection Reasoning:', llmReasoning);
        }
        if (coverageInfo) {
          console.log('ðŸ“Š LLM Coverage Analysis:', coverageInfo);
        }
        
        // Log all selection reasons for debugging
        console.log('ðŸ“‹ Full Selection Details:');
        selectionResult.selectionReasons.forEach((reason, index) => {
          console.log(`   ${index + 1}. ${reason}`);
        });

        sendUpdate({
          type: 'step_update',
          stepId: 'document_selection',
          status: 'completed',
          message: generateStepMessage('document_selection', { 
            selectedDocs: filesToAnalyze.length, 
            totalDocs: allPDFs.length
          })
        });

        // Dynamic Step 5: Content Extraction
        sendUpdate({
          type: 'step_update',
          stepId: 'content_extraction',
          status: 'in_progress',
          message: generateStepMessage('content_extraction', { selectedDocs: filesToAnalyze.length })
        });

        const pdfFiles = filesToAnalyze.map(pdf => ({
          filename: pdf.filename,
          filepath: path.join(COMPANIES_DIR, pdf.company || 'default', pdf.filename),
          company: pdf.company
        }));

        await new Promise(resolve => setTimeout(resolve, 1200));

        sendUpdate({
          type: 'step_update',
          stepId: 'content_extraction',
          status: 'completed',
          message: generateStepMessage('content_extraction', { selectedDocs: filesToAnalyze.length })
        });

        // Dynamic Step 6: Data Analysis
        const analysisType = question.includes('gelir') || question.includes('revenue') ? 'Gelir' :
                           question.includes('kar') || question.includes('profit') ? 'Kar' :
                           question.includes('bÃ¼yÃ¼me') || question.includes('growth') ? 'BÃ¼yÃ¼me' :
                           question.includes('deÄŸiÅŸim') || question.includes('change') ? 'DeÄŸiÅŸim' : 'Finansal';

        sendUpdate({
          type: 'step_update',
          stepId: 'data_analysis',
          status: 'in_progress',
          message: generateStepMessage('data_analysis', { analysisType })
        });

        await new Promise(resolve => setTimeout(resolve, 800));

        // Dynamic Step 7: Response Generation
        sendUpdate({
          type: 'step_update',
          stepId: 'response_generation',
          status: 'in_progress',
          message: generateStepMessage('response_generation')
        });

        // Analyze with Claude
        const analysisResult = await analyzeWithClaude(
          { question, context },
          pdfFiles
        );

        sendUpdate({
          type: 'step_update',
          stepId: 'response_generation',
          status: 'completed',
          message: generateStepMessage('response_generation')
        });

        // Dynamic Step 8: Chart Creation (if chart data exists)
        if (analysisResult.chartData) {
          sendUpdate({
            type: 'step_update',
            stepId: 'chart_creation',
            status: 'in_progress',
            message: generateStepMessage('chart_creation')
          });

          await new Promise(resolve => setTimeout(resolve, 600));

          sendUpdate({
            type: 'step_update',
            stepId: 'chart_creation',
            status: 'completed',
            message: generateStepMessage('chart_creation')
          });
        }

        // Send final result
        const response = {
          success: true,
          ...analysisResult,
          filesAnalyzed: pdfFiles.length,
          totalFilesAvailable: allPDFs.length,
          companiesAvailable: [...new Set(pdfFiles.map(pdf => pdf.company).filter(Boolean))],
          selectionInfo: {
            totalScore: selectionResult.totalScore,
            reasons: selectionResult.selectionReasons,
            droppedCount: selectionResult.droppedPDFs.length
          },
          timestamp: new Date().toISOString()
        };

        sendUpdate({
          type: 'final_result',
          data: response
        });

        controller.close();

      } catch (error) {
        console.error('=== STREAMING ANALYZE API ERROR ===', error);
        
        const sendUpdate = (update: ProcessUpdate) => {
          const data = `data: ${JSON.stringify(update)}\n\n`;
          controller.enqueue(encoder.encode(data));
        };

        // Handle specific error types
        let errorMessage = 'Analysis failed: ' + (error as Error).message;
        
        if (error instanceof Error) {
          if (error.message.includes('rate_limit_error') || error.message.includes('429')) {
            errorMessage = 'API rate limit reached. Please wait a few minutes and try again.';
          } else if (error.message.includes('request_too_large')) {
            errorMessage = 'Request too large. Please try with fewer documents.';
          } else if (error.message.includes('ENOENT') || error.message.includes('no such file')) {
            errorMessage = 'Some PDF files could not be found. Please re-upload your documents.';
          }
        }

        sendUpdate({
          type: 'error',
          message: errorMessage
        });
        
        controller.close();
      }
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}